events {}

http {
    # ========================
    # Docker DNS integration
    # ========================
    # 127.0.0.11 is Docker's internal DNS server.
    # This lets NGINX resolve "tts-api" to ALL container replicas dynamically.
    resolver 127.0.0.11 valid=10s;
    resolver_timeout 5s;

    # ========================
    # REST upstream
    # ========================
    upstream rest_upstream {
        zone rest_upstream 64k;         # Shared memory zone, keeps health/load state across workers
        server tts-api:8080 resolve;    # "tts-api" resolves to all replicas' IPs
        least_conn;                     # Pick the replica with the fewest active connections
        keepalive 32;                   # Reuse up to 32 idle connections (reduce TCP overhead)
    }

    # ========================
    # gRPC upstream
    # ========================
    upstream grpc_upstream {
        zone grpc_upstream 64k;
        server tts-api:5001 resolve;
        least_conn;
        keepalive 32;
    }

    # ========================
    # Common proxy settings
    # ========================
    proxy_connect_timeout 3s;    # Time to establish a backend connection
    proxy_send_timeout 30s;      # Time to send request to backend
    proxy_read_timeout 60s;      # Max time to wait for backend response
    send_timeout 60s;            # Max time to send response to client
    client_max_body_size 50m;    # Allow up to 50 MB request payload (TTS text/audio)
    proxy_buffering on;          # Enable buffering (better for REST, not gRPC)

    # ========================
    # REST Server (HTTP/JSON)
    # ========================
    server {
        listen 8080;

        # Health check endpoint for monitoring
        location /health {
            access_log off;
            return 200 'OK';
        }

        location / {
            proxy_pass http://rest_upstream;
            proxy_http_version 1.1;

            # Forward client info
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Retry if backend fails
            proxy_next_upstream error timeout http_502 http_503 http_504;
        }
    }

    # ========================
    # gRPC Server
    # ========================
    server {
        listen 5001 http2;   # gRPC requires HTTP/2

        location /health {
            access_log off;
            return 200 'OK';
        }

        location / {
            grpc_pass grpc://grpc_upstream;
            proxy_http_version 1.1;

            # Forward client info
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_next_upstream error timeout http_502 http_503 http_504;
        }
    }
}
